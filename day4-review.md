# Day 4: Wrap & Analyze — 복습 노트

> 작성일: 2026-02-23
> Block 0~2 진행 중 대화 정리

---

## 1. 스킬 설치 시 나오는 메시지, 에러 아닌 것들

스킬 설치(`npx skills add ...`) 후 터미널에 나오는 메시지 중 에러처럼 보이지만 **에러가 아닌 것들**이 있다.

### Security Risk Assessments (보안 위험 평가)

```
day2-supplement-mcp    High Risk    0 alerts    Critical Risk
```

- 에러가 아니라, 스킬의 보안 위험도를 **자동 분석한 참고 정보**
- 스킬이 시스템 명령을 실행할 수 있기 때문에 경고를 보여주는 것
- 캠프 공식 스킬이라 안전함

### npm notice

```
npm notice New major version of npm available! 10.9.4 -> 11.10.1
```

- 에러가 아니라, npm의 새 버전이 있다는 **안내 메시지**
- 무시해도 됨

### 에러인지 아닌지 판단하는 팁

- 터미널에서 **빨간색이 아닌 노란색/회색 메시지**는 대부분 "경고(warning)" 또는 "안내(notice)"
- `error`라는 단어가 포함되어 있지 않으면 보통 정상 동작

---

## 2. Multi-agent란?

### 비유: "회사 퇴근 전 마감 회의"

회사에서 퇴근 전에 팀장 4명에게 **동시에** 보고를 받는 상황을 떠올려보자.

| 팀장 | 보고 내용 |
|------|-----------|
| 문서담당 | "오늘 보고서 3건 업데이트했습니다" |
| 자동화담당 | "매주 반복되는 이 작업, 자동화할 수 있습니다" |
| 학습담당 | "이번 주 프로젝트에서 이런 걸 배웠습니다" |
| 후속작업담당 | "다음 주에 이것부터 해야 합니다" |

Claude Code도 똑같이 한다. 하나의 Claude가 혼자 다 하는 게 아니라, **여러 전문 에이전트(sub-agent)에게 동시에 일을 시킨다.**

Day 1에서 배운 subagent(Task)의 확장 — 그때는 1개였다면, 이제는 **여러 개를 동시에** 쓰는 것.

---

## 3. 2-Phase Pipeline (핵심 패턴)

Multi-agent를 실제로 쓸 때 가장 많이 쓰는 패턴.

### Phase 1: 4명의 전문가가 동시에 분석 (병렬)

| 전문가 | 하는 일 |
|--------|---------|
| doc-updater | 문서 중 업데이트가 필요한 곳을 찾아냄 |
| automation-scout | 반복되는 패턴을 발견하고 자동화를 제안 |
| learning-extractor | 오늘 배운 것을 정리 |
| followup-suggester | 다음에 할 일을 제안 |

> "병렬"이란? 4명에게 **한꺼번에** 보고를 받는 것. (반대: "순차" = 한 명씩 차례로)

### Phase 2: 중복 검증

| 전문가 | 하는 일 |
|--------|---------|
| duplicate-checker | Phase 1 결과에서 겹치는 내용을 걸러냄 |

### 왜 Phase 2가 필요한가?

전문가 4명이 독립적으로 일하면 **비슷한 걸 제안할 수 있기 때문**.

예시:
- doc-updater: "README 업데이트 필요"
- followup-suggester: "다음에 README 수정하세요"
- → 중복! duplicate-checker가 이런 중복을 정리해서 깔끔한 결과만 남긴다.

### 병렬 처리의 핵심 가치

- 4개 에이전트를 **순차**로 실행하면 → 4배 시간
- **동시에** 실행하면 → 가장 느린 1개의 시간만 걸림

---

## 4. session-wrap이란?

### 비유: "퇴근 전 책상 정리 루틴"

매일 퇴근 전에 하는 루틴: 오늘 한 일 정리 → 배운 것 메모 → 내일 할 일 목록 작성 → 서류 정돈

**session-wrap**은 Claude Code 세션을 끝낼 때 자동으로 실행되는 "종합 정리 스킬". Multi-agent + 2-Phase Pipeline을 활용해서, 오늘의 작업을 체계적으로 정리해준다.

### 전체 흐름

```
┌─────────────────────────────────────────────────┐
│  1. 변경 내용 확인 (오늘 뭘 했나?)                  │
├─────────────────────────────────────────────────┤
│  2. Phase 1: 4명의 전문가 동시 분석               │
│     ┌────────────────┬────────────────┐          │
│     │  문서 업데이트    │  자동화 발견    │          │
│     ├────────────────┼────────────────┤          │
│     │  배운 것 정리    │  다음 할 일     │          │
│     └────────────────┴────────────────┘          │
├─────────────────────────────────────────────────┤
│  3. Phase 2: 중복 검증 (같은 말 안 하게)           │
├─────────────────────────────────────────────────┤
│  4. 결과 통합 + 사용자 선택                        │
├─────────────────────────────────────────────────┤
│  5. 선택한 작업 실행                               │
└─────────────────────────────────────────────────┘
```

정리하면, session-wrap은 **"퇴근 전에 Claude가 알아서 팀장 4명에게 보고를 받고, 중복을 정리해서 깔끔하게 보여주는 것"**.

---

## 5. 헷갈렸던 것: 스킬 vs 서브에이전트

### 이전 세션에서 배운 것 (개별 스킬)

Notion에 daily scrum 작성하는 스킬, trouble shooting 작성하는 스킬 → **각각 별개의 스킬 파일**

```
.claude/skills/
├── my-daily-scrum/SKILL.md      ← 스킬 1
├── my-trouble-shooting/SKILL.md ← 스킬 2
```

### 오늘 배우는 것 (하나의 스킬 안의 서브에이전트)

session-wrap은 **하나의 스킬 안에서** 여러 서브에이전트가 동시에 일하는 구조.

```
session-wrap/SKILL.md  ← 스킬 1개
  └── 안에서 동시에 실행되는 서브에이전트 4개
      ├── doc-updater
      ├── automation-scout
      ├── learning-extractor
      └── followup-suggester
```

### 핵심 차이

| 개념 | 비유 | 예시 |
|------|------|------|
| **스킬 (Skill)** | 각각 독립된 "업무 매뉴얼" | `/daily-scrum`, `/trouble-shooting` |
| **서브에이전트 (Sub-agent)** | 하나의 매뉴얼 **안에서** 동시에 일하는 "팀원들" | doc-updater, automation-scout 등 |

### 정리

- **스킬 = "무엇을 할지"** (명령어 단위)
- **서브에이전트 = "어떻게 할지"** (스킬 내부의 실행 방식)
- 간단한 작업은 스킬 1개에 에이전트 0개로도 충분
- 복잡한 작업은 스킬 1개 안에 에이전트 여러 개를 두는 것
- 이전에 구상한 daily-scrum, trouble-shooting 같은 **개별 스킬도 유효한 설계**
- 거기에 더해서, 하나의 스킬이 **내부적으로 여러 에이전트를 동시에 굴리는 패턴**을 배우는 것

둘 다 맞는 얘기:

```
방법 A: 스킬을 여러 개 만든다 (이전 세션)
  /daily-scrum → Notion에 데일리 스크럼 작성
  /trouble-shooting → Notion에 트러블슈팅 작성

방법 B: 하나의 스킬 안에서 여러 에이전트가 동시에 일한다 (오늘)
  /session-wrap → 에이전트 4명이 동시 분석 → 결과 통합
```

---

## 6. 2-Phase Pipeline은 퇴근 전에만 쓰는 게 아니다

2-Phase Pipeline은 **범용 패턴**이다. "여러 명이 동시에 분석 → 결과 정리"가 필요한 상황이면 언제든 쓸 수 있다.

| 상황 | Phase 1 (병렬 분석) | Phase 2 (정리) |
|------|---------------------|----------------|
| 코드 리뷰 | 보안 체크, 성능 체크, 스타일 체크 동시에 | 중복 피드백 제거 |
| 콘텐츠 기획 | 트렌드 조사, 경쟁사 분석, 타겟 분석 동시에 | 겹치는 인사이트 통합 |
| 버그 분석 | 로그 분석, 코드 분석, 환경 체크 동시에 | 원인 후보 우선순위 정리 |
| 면접 준비 | 기술 질문, 인성 질문, 회사 조사 동시에 | 겹치는 답변 포인트 정리 |

핵심 조건: **"독립적으로 분석 가능한 작업이 여러 개"** + **"결과를 합칠 때 중복이 생길 수 있다"** → 이 두 조건이 맞으면 2-Phase Pipeline을 쓸 수 있다.

---

## 7. session-wrap은 세션 끝에만 쓰는 게 아니다

session-wrap 자체는 세션을 끝낼 때 쓰는 스킬이 맞지만, "세션"의 범위는 유연하다.

| 시점 | 예시 |
|------|------|
| 기능 하나 완성했을 때 | "로그인 기능 다 만들었다, 정리하자" |
| 점심 먹으러 가기 전 | "오전 작업 정리하고 갈게" |
| 브랜치 전환 전 | "이 작업 마무리하고 다른 거 하자" |
| 하루 끝 | "오늘 작업 끝, 내일 할 일 정리" |

**session = 하루가 아니라 "작업 단위"**. 하루에 session-wrap을 2~3번 돌려도 괜찮다.

정리를 자주 할수록 "어디까지 했더라?" 하고 헤매는 시간이 줄어든다.

### session-wrap 사용 흐름 (핵심 비유)

```
작업을 했다 → /my-session-wrap → 정리됨
            ↑
         이 타이밍은 내가 정하는 것!
         퇴근 전이든, 점심 전이든, 기능 완성 후든.
```

session-wrap은 **"이 세션에서 뭘 했는지"를 분석해서 정리하는 스킬**이다. 그래서 **먼저 작업을 해야** 정리할 내용이 생긴다.

```
비유:
1. 회사에서 보고서 3개를 작성한다     ← 오늘의 업무
2. 퇴근 전에 "오늘 뭐 했지?" 정리한다  ← session-wrap

업무를 안 했으면 정리할 것도 없다!
```

아무것도 안 하고 session-wrap을 돌리면 "변경 사항 없음"이라고만 나온다. **빈 책상을 정리하는 것과 같다.**

---

## 8. Block 1: session-wrap 스킬 직접 만들기

### SKILL.md를 6단계로 만든다

요리 레시피를 쓰는 것과 같은 구조:

```
Step 1: 요리 이름과 소개     → frontmatter (이 스킬이 뭔지 한 줄 소개)
Step 2: 완성 사진             → 다이어그램 (전체 흐름을 한눈에)
Step 3: 재료 준비             → 변경 내용 확인 (오늘 뭘 했는지 파악)
Step 4: 4가지 반찬 동시 조리  → 병렬 에이전트 (각자 다른 분석을 동시에)
Step 5: 맛 검수               → 검증 에이전트 (중복이나 빠진 게 없는지 확인)
Step 6: 상차리기              → 결과 통합 (정리해서 보여주고, 실행할 것 선택)
```

### Step 1: frontmatter (이름표)

```yaml
---
name: my-session-wrap
description: 세션 종료 시 작업 정리, 문서 업데이트, 학습 기록을 하는 스킬. "/wrap", "세션 정리", "마무리" 요청에 사용.
---
```

- `---`로 감싼 부분이 **frontmatter(이름표)**
- `name`: Claude가 이 스킬을 식별하는 이름
- `description`: 사용자가 `/wrap`, `세션 정리`, `마무리`라고 말하면 Claude가 이 스킬을 찾아 실행하게 해주는 키워드

### Step 2: Execution Flow (다이어그램)

```
┌─────────────────────────────────────────────────────┐
│  Step 1: Git 상태 확인                                │
├─────────────────────────────────────────────────────┤
│  Step 2: Phase 1 — 4개 분석 에이전트 (병렬 실행)       │
│  ┌────────────────────┬────────────────────┐         │
│  │  doc-updater       │  automation-scout  │         │
│  ├────────────────────┼────────────────────┤         │
│  │  learning-extractor│  followup-suggester│         │
│  └────────────────────┴────────────────────┘         │
├─────────────────────────────────────────────────────┤
│  Step 3: Phase 2 — 검증 에이전트 (순차 실행)           │
├─────────────────────────────────────────────────────┤
│  Step 4: 결과 통합                                    │
├─────────────────────────────────────────────────────┤
│  Step 5: 사용자 선택 + 실행                           │
└─────────────────────────────────────────────────────┘
```

- 이 다이어그램은 사람만 보는 게 아니다. **Claude도 이걸 읽고 실행 순서를 파악**한다
- "병렬 실행"이라고 적으면 Claude가 Task 도구로 4개를 동시 호출, "순차 실행"이면 하나씩 처리

### Step 3: 변경 내용 확인

- `git status`, `git diff --stat`, `git log --oneline -10` 명령을 Claude가 **Bash 도구로 자동 실행**
- 결과를 일관된 형식으로 요약:
  ```
  📋 세션 요약
  - 변경된 파일: (개수)개
  - 새로 만든 파일: (목록)
  - 수정한 파일: (목록)
  - 커밋 현황: (커밋 수)건
  ```

### Step 4: Phase 1 — 병렬 에이전트 4개

각 에이전트는 `Task 도구(subagent_type: "general-purpose")`로 **동시 호출**된다.

| 에이전트 | 역할 | 출력 |
|----------|------|------|
| doc-updater | 프로젝트 문서 중 업데이트 필요한 곳 찾기 | 📝 문서 업데이트 제안 |
| automation-scout | 반복 패턴 발견 → 자동화 제안 | 🤖 자동화 제안 |
| learning-extractor | 이 세션에서 새로 배운 것 정리 | 💡 오늘 배운 것 |
| followup-suggester | 다음 세션에서 이어서 할 작업 제안 | 📌 다음에 할 일 |

- 각 에이전트에 **출력 형식을 미리 정해두면** Claude가 매번 일관된 포맷으로 결과를 만들어준다
- 4개가 서로 의존하지 않으므로 동시에 실행해서 시간 절약

### Step 5: Phase 2 — 검증 에이전트

| 에이전트 | 역할 |
|----------|------|
| duplicate-checker | Phase 1 결과에서 중복되는 제안을 찾아 정리 |

- **완전 중복**: 같은 파일에 같은 작업 제안 → 하나만 남기고 제거
- **부분 중복**: 비슷한 주제의 다른 제안 → 하나로 병합 제안
- **고유 항목**: 중복 없음 → 그대로 유지
- **순차 실행**인 이유: Phase 1 결과가 전부 모여야 중복을 비교할 수 있기 때문

### Step 6: 결과 통합 + 사용자 선택

- Phase 1 + Phase 2 결과를 하나의 **통합 보고서**로 정리해서 보여준다
- `AskUserQuestion`으로 실행할 작업을 **사용자가 직접 선택** (multiSelect: true)
  - 커밋 생성
  - 문서 업데이트
  - 자동화 생성
  - 건너뛰기
- 선택한 작업**만** 실행. 자동으로 강제 실행하지 않는다

### 퀴즈에서 배운 것

**Q: Phase 1의 4개 에이전트가 '병렬'로 실행되는 이유는?**
**A: 서로 의존하지 않아서 동시에 실행 가능.** 각자 독립적인 분석(문서, 패턴, 학습, 후속작업)을 하므로 서로 기다릴 필요가 없다.

---

## 9. Block 2: 실행 & 검증

### 실행 전 확인할 3가지

1. **파일 존재 여부**: `.claude/skills/my-session-wrap/SKILL.md`가 있는지
2. **frontmatter 확인**: name과 description이 올바른지
3. **Claude 인식 확인**: "어떤 스킬이 설치되어 있어?"로 목록에 나오는지

### 실행 후 볼 3가지

1. **4개 에이전트 병렬 실행**: "Task 실행 중..." 또는 에이전트 이름이 여러 개 보이면 정상
2. **Phase 2 검증**: 결과를 종합하고 중복 정리하는 단계가 동작하는지
3. **AskUserQuestion 선택지**: "어떻게 할까요?" 선택지가 나오는지

### 스킬 호출 방법 2가지

| 방법 | 예시 | 원리 |
|------|------|------|
| 직접 호출 | `/my-session-wrap` | 스킬 이름으로 직접 찾기 |
| 자동 매칭 | `세션 정리해줘` | description의 키워드로 Claude가 자동 매칭 |

둘 다 같은 스킬이 실행된다.

### 문제가 있을 때 확인할 것

| 증상 | 원인 | 해결 |
|------|------|------|
| 스킬이 인식 안 됨 | frontmatter (name, description)이 잘못됨 | SKILL.md 상단 확인 |
| 에이전트가 2개만 실행됨 | 나머지 2개의 Task 호출이 빠짐 | SKILL.md에 4개 모두 있는지 확인 |
| 병렬이 아니라 순차 실행됨 | Task 호출이 따로따로 되어 있음 | 한 메시지에 4개 Task를 모아야 함 |
| 선택지가 안 나옴 | AskUserQuestion 호출 부분 누락 | Step 5 섹션 확인 |

> **Plan B**: "session-wrap 원본 스킬을 참고해서 내 my-session-wrap을 완성해줘"라고 입력하면 Claude가 자동 보정

### 퀴즈에서 배운 것 (Block 0)

**Q: Phase 2(duplicate-checker)가 필요한 이유는?**
**A: 4명의 전문가가 비슷한 제안을 할 수 있어서.** 독립적으로 분석하면 중복이 생길 수 있고, duplicate-checker가 이를 걸러내서 깔끔한 결과만 남긴다.

### 퀴즈에서 배운 것 (Block 2): frontmatter는 단순한 이름표가 아니다

**Q: 스킬이 의도대로 동작하지 않을 때, 가장 먼저 확인해야 할 것은?**
**A: SKILL.md의 frontmatter (name, description)**

frontmatter는 **Claude가 스킬을 발견하고 매칭하는 메커니즘**이다.

```
사용자: "세션 정리해줘"
         ↓
Claude: description에서 "세션 정리" 키워드를 검색
         ↓
      name: my-session-wrap  ← 이걸로 스킬 파일을 찾음
      description: "... 세션 정리 ..."  ← 여기서 매칭됨!
         ↓
      SKILL.md 본문을 읽고 실행
```

frontmatter가 잘못되면 벌어지는 일:

| 문제 | 결과 |
|------|------|
| `name`이 없거나 오타 | Claude가 스킬 파일 자체를 못 찾음 |
| `description`이 비어있음 | 자연어로 매칭이 안 됨 |
| `description`에 키워드가 없음 | `/my-session-wrap`으로만 호출 가능 |
| `---`를 빼먹음 | 스킬 목록에 아예 안 나타남 |

**비유: frontmatter = 가게 간판 + 전화번호부 등록**

- 간판이 없으면 → 손님이 가게를 못 찾음 (스킬 인식 불가)
- 전화번호부에 안 올리면 → 검색해도 안 나옴 (자연어 매칭 불가)
- 가게 내부(에이전트 프롬프트)가 아무리 좋아도, 간판이 없으면 손님이 들어올 수가 없다!

**확인 순서**: frontmatter (찾을 수 있나?) → 에이전트 프롬프트 (결과가 좋나?) → Git 상태 (분석할 게 있나?)

---

## Claude Code 팁

### skills-lock.json의 역할

- npm의 `package-lock.json`과 비슷한 역할
- 설치된 스킬의 **출처와 해시값**을 관리해서 버전 일관성을 보장
- 커리큘럼 스킬(day1, day2 등)은 GitHub에서 설치된 것 → lock 파일에 기록됨
- `my-*` 스킬(my-session-wrap 등)은 로컬에서 직접 만든 것 → lock 파일에는 없음

### `.claude` 폴더는 2곳에 있다

이름이 같아서 헷갈리지만 **완전히 다른 폴더**:

| 위치 | 경로 | 용도 |
|------|------|------|
| **프로젝트 안** | `~/Desktop/camp-1/.claude/` | 스킬, 프로젝트 설정 (git에 포함) |
| **홈 폴더** | `~/.claude/` (= `/Users/osejin/.claude/`) | 세션 기록, 플러그인, 전역 설정 (개인 데이터) |

```
~/Desktop/camp-1/.claude/     ← 프로젝트용 (스킬, 설정)
~/.claude/                    ← 전역용 (세션 기록, 플러그인)
  └── projects/
      └── -Users-osejin-Desktop-camp-1/  ← 여기에 세션 기록!
```

Finder에서 홈 폴더의 `.claude` 보려면: `Cmd + Shift + G` → `~/.claude/projects/` 입력

### 세션 기록과 세션 만료는 다른 것

Claude Code의 모든 대화는 **실시간으로 저장**된다.

```
대화 시작 → 메시지 1 저장 → 메시지 2 저장 → ... → 세션 종료
              ↑                ↑
         대화할 때마다 바로바로 .jsonl 파일에 기록됨
```

| 상황 | 대화 기록 (파일) | 컨텍스트 (기억) |
|------|-----------------|----------------|
| 세션 진행 중 | ✅ 저장됨 | ✅ Claude가 기억 |
| 세션 만료/종료 | ✅ 저장됨 | ❌ Claude가 잊음 |
| 새 세션 시작 | 이전 기록은 파일에 남아있음 | 새로 시작 (기억 없음) |

**핵심 구분:**
- **기록(파일)**: 영구 저장. 사라지지 않음. 갑자기 컴퓨터가 꺼져도 그 전까지의 대화는 남아있음
- **컨텍스트(기억)**: 세션이 끝나면 초기화됨

세션 만료 = "Claude가 잊는 것"이지 "기록이 사라지는 것"이 아니다. history-insight는 이 **"잊혀진 기록"을 다시 발굴**하는 도구.

---

## 10. Block 3: History Insight — 세션 히스토리 분석

### 세션 히스토리란?

Claude Code와 대화할 때마다 **일기장처럼** 기록이 자동 저장된다.

- 위치: `~/.claude/projects/` 폴더 안에 자동 저장
- 프로젝트별로 폴더가 나뉘어 있음
- 하나의 세션(대화) = 하나의 `.jsonl` 파일

### history-insight가 하는 일

이 "일기장"을 읽어서 유용한 패턴을 찾아주는 스킬. **과거의 자기 자신에게서 배우는 것.**

| 질문 | history-insight가 해주는 것 |
|------|---------------------------|
| "이번 주에 가장 많이 한 작업?" | 세션별 작업 내용을 분류하고 빈도순 정리 |
| "자주 하는 실수 패턴?" | 반복되는 오류, 재시도 패턴 추출 |
| "프로젝트별 작업 정리?" | 프로젝트 폴더별 세션 분류 및 요약 |

### 세션 파일의 실제 대화 비중은 약 6%

세션 `.jsonl` 파일의 94%는 파일 변경 이력, 도구 호출 로그 같은 부속 자료. 실제 대화는 **약 6%만** 차지한다. history-insight는 이 핵심 6%만 추출해서 분석한다.

```
두꺼운 일기장에서:
- 실제로 쓴 글 = 약 6% (핵심 대화)
- 날짜 도장, 영수증 등 = 약 94% (부속 자료)

history-insight는 부속 자료를 걷어내고 실제 대화만 분석
```

### my-session-wrap vs history-insight

| 스킬 | 하는 일 | 시간 범위 |
|------|---------|-----------|
| my-session-wrap | 현재 세션에서 한 작업을 정리 | **지금** (오늘) |
| history-insight | 과거 모든 세션 기록을 분석 | **그동안 전체** |

비유: session-wrap은 "오늘 일기 쓰기", history-insight는 "지난 한 달 일기장 분석"

### 스킬 없이도 같은 작업 가능

history-insight 스킬이 설치되어 있지 않아도, Claude에게 자연어로 직접 요청할 수 있다:
```
내 Claude Code 세션 기록을 분석해줘.
~/.claude/projects/ 에서 이 프로젝트의 세션 파일들을 확인하고,
어떤 작업들을 했는지 패턴을 찾아줘.
```

**스킬은 "자동화된 지시서"일 뿐.** 스킬이 없어도 같은 결과를 얻을 수 있다.

---

## 11. Block 4: Session Analyzer — 스킬 실행 검증

### 왜 검증이 필요한가?

SKILL.md에 "이렇게 해라"라고 써놨다고 Claude가 100% 그대로 실행한다는 보장이 없다. **스킬을 만드는 것과 스킬이 올바르게 동작하는 것은 다른 문제.**

비유: 요리 레시피를 작성했으면, 레시피대로 만들었는지 확인해야 한다. 소금을 넣으라고 했는데 설탕을 넣었을 수도 있다.

### session-analyzer가 하는 일

**SKILL.md(설계도)와 실제 실행 기록을 비교**하는 도구. 비유하면 "감독관".

| 단계 | 하는 일 | 비유 |
|------|---------|------|
| 1 | 세션 파일 찾기 | CCTV 녹화본 찾기 |
| 2 | SKILL.md 파싱 | 설계도 읽기 |
| 3 | 세션 기록 분석 | CCTV 녹화본 재생 |
| 4 | 아티팩트 검증 | 결과물 현장 확인 |
| 5 | Expected vs Actual 비교 | 설계도 vs 현장 대조표 |
| 6 | 리포트 생성 | 합격/불합격 판정 |

### 실제 검증 결과 (직접 체험)

session-analyzer 스킬 없이 Claude에게 직접 요청해서 검증한 결과:

```
SKILL.md 설계: ✅ 5개 Step 모두 완성
실제 실행:     ❌ 한 번도 실행되지 않음
최종 판정:     FAIL — 실행 기록 없음
```

SKILL.md를 고칠 필요는 없었다. 설계는 완벽한데 실행을 안 한 것이 원인.

```
비유: 시험지를 완벽하게 작성했는데 제출을 안 한 상태
     → 답을 고칠 게 아니라 제출 버튼을 눌러야 함
```

### FAIL의 두 가지 원인

| 원인 | 해결 방법 |
|------|-----------|
| SKILL.md 설계에 결함 (에이전트가 빠짐 등) | SKILL.md 수정 |
| 스킬을 실행하지 않음 | 스킬 실행 (`/my-session-wrap`) |

### 퀴즈에서 배운 것 (Day 4 종합)

**Q: 스킬을 만들고 → 실행하고 → 검증하는 과정에서 가장 중요한 원칙은?**
**A: 만들기 → 실행 → 검증의 반복 (iteration)**

한 번에 완벽한 스킬은 없다. 반복하면서 개선하는 것이 핵심.

---

## 12. Day 4 종합 정리

### 오늘 배운 3가지 핵심

1. **Multi-agent 패턴**: 여러 전문가에게 동시에 일을 시키고, 결과를 검증하는 구조
2. **스킬 만들기**: SKILL.md 하나로 나만의 자동화 워크플로우 구축
3. **검증 루프**: 만들고 → 실행하고 → 분석하는 반복이 품질을 만든다

### 오늘 배운 스킬 3개

| 스킬 | 하는 일 | 비유 | 상태 |
|------|---------|------|------|
| my-session-wrap | 현재 세션 작업 정리 | 퇴근 전 오늘 한 일 정리 | ✅ 직접 만듦 |
| history-insight | 과거 전체 세션 분석 | 지난 한 달 일기장 분석 | ❌ 미설치 |
| session-analyzer | 스킬 실행 검증 | 레시피대로 요리했는지 검수 | ❌ 미설치 |

### 핵심 사이클

```
만들기 (Block 1)
  ↓
실행하기 (Block 2)
  ↓
검증하기 (Block 4)
  ↓
문제 발견 → 다시 만들기로 (반복!)
```

### 스킬을 다른 프로젝트에서 쓰는 법

| 방법 | 명령어 | 용도 |
|------|--------|------|
| 플러그인 설치 | `npx skills add <소스> --agent claude-code --yes` | 외부 스킬 패키지 |
| 파일 복사 | `cp -r 원본경로 대상경로` | 직접 만든 스킬을 다른 프로젝트로 |
| 직접 생성 | SKILL.md 파일 만들기 | 새 스킬 만들기 |

스킬의 실체는 **SKILL.md 파일 하나**이기 때문에, 복사만 하면 다른 프로젝트에서도 바로 사용 가능.

---

## 진행 완료

- [x] Block 0: 개념 이해 + 퀴즈
- [x] Block 1: session-wrap SKILL.md 직접 작성 + 퀴즈
- [x] Block 2: 실행 & 검증 + 퀴즈
- [x] Block 3: History Insight + 퀴즈
- [x] Block 4: Session Analyzer + 종합 퀴즈

### 남은 할 일

- [ ] `/my-session-wrap` 실제 실행해서 PASS 받기
- [ ] cuddle-market 프로젝트에 history-insight 스킬 직접 만들기
